from textwrap import dedent

from inflection import underscore

from fluidsimfoam.foam_input_files import DEFAULT_HEADER, Dict, FoamInputFile
from fluidsimfoam.foam_input_files.blockmeshhelper import BlockMeshDict, Vertex
from fluidsimfoam.output import Output

code_control_dict_functions = dedent(
    """
    functions
    {
        #includeFunc solverInfo
        #includeFunc streamlines
    }
"""
)

_attribs_transport_prop = {
    "transportModel": "Newtonian",
    "nu": 0.001,
    "beta": 1.88583,
    "TRef": 300,
    "Pr": 1.0,
    "Prt": 1.0,
}


class OutputCBox(Output):
    """Output for the cbox solver"""

    variable_names = ["T", "U", "alphat", "epsilon", "k", "nut", "p", "p_rgh"]
    system_files_names = Output.system_files_names + [
        "blockMeshDict",
        "solverInfo",
        "streamlines",
    ]
    constant_files_names = Output.constant_files_names + ["g"]

    # @classmethod
    # def _set_info_solver_classes(cls, classes):
    #     """Set the the classes for info_solver.classes.Output"""
    #     super()._set_info_solver_classes(classes)

    @classmethod
    def _complete_params_control_dict(cls, params):
        super()._complete_params_control_dict(params)

        default = {
            "application": "buoyantBoussinesqPimpleFoam",
            "startFrom": "latestTime",
            "endTime": 1000,
            "deltaT": 1,
            "writeControl": "runTime",
            "writeInterval": 50,
            "writeFormat": "binary",
        }

        for key, value in default.items():
            params.control_dict[underscore(key)] = value

    def make_code_control_dict(self, params):
        code = super().make_code_control_dict(params)
        return code + code_control_dict_functions

    @classmethod
    def _complete_params_transport_properties(cls, params):
        params._set_child(
            "transport_properties",
            attribs=_attribs_transport_prop,
            doc="""TODO""",
        )

    def make_tree_transport_properties(self, params):
        return FoamInputFile(
            info={
                "version": "2.0",
                "format": "ascii",
                "class": "dictionary",
                "object": "transportProperties",
            },
            children={
                key: params.transport_properties[key]
                for key in _attribs_transport_prop.keys()
            },
            header=DEFAULT_HEADER,
            comments={
                "nu": "Laminar viscosity",
                "beta": "Thermal expansion coefficient",
                "TRef": "Reference temperature",
                "Pr": "Laminar Prandtl number",
                "Prt": "Turbulent Prandtl number",
            },
        )

    def make_tree_turbulence_properties(self, params):
        tree = super().make_tree_turbulence_properties(params)
        # TODO: fix this bad API (need for `Dict` and `name`)
        tree.children["RAS"] = Dict(
            {"RASModel": "kEpsilon", "turbulence": "on", "printCoeffs": "on"},
            name="RAS",
        )
        return tree

    @classmethod
    def _complete_params_block_mesh_dict(cls, params):
        super()._complete_params_block_mesh_dict(params)
        bmdp = params.block_mesh_dict

        bmdp.num_mesh_x = 80
        bmdp.num_mesh_y = 80
        bmdp.num_mesh_z = 1
        bmdp.length_x = 1.0
        bmdp.length_y = 1.0
        bmdp.length_z = 0.1

    def make_code_block_mesh_dict(self, params):
        num_mesh_x = params.block_mesh_dict.num_mesh_x
        num_mesh_y = params.block_mesh_dict.num_mesh_y
        num_mesh_z = params.block_mesh_dict.num_mesh_z

        length_x = params.block_mesh_dict.length_x
        length_y = params.block_mesh_dict.length_y
        length_z = params.block_mesh_dict.length_z

        bmd = BlockMeshDict()

        bmd.set_metric(params.block_mesh_dict.metric)

        basevs = [
            Vertex(0, 0, length_z, "v0"),
            Vertex(length_x, 0, length_z, "v1"),
            Vertex(length_x, length_y, length_z, "v2"),
            Vertex(0, length_y, length_z, "v3"),
        ]

        for v in basevs:
            bmd.add_vertex(v.x, v.y, 0, v.name + "-0")
            bmd.add_vertex(v.x, v.y, v.z, v.name + "+z")

        # utility to to generate vertex names
        def vnamegen(x0z0, x1y0, x1y1, x0z1):
            return (
                x0z0 + "-0",
                x1y0 + "-0",
                x1y1 + "-0",
                x0z1 + "-0",
                x0z0 + "+z",
                x1y0 + "+z",
                x1y1 + "+z",
                x0z1 + "+z",
            )

        # Noted that 'v0+y' and 'v3+y' are still valid
        b0 = bmd.add_hexblock(
            vnamegen("v0", "v1", "v2", "v3"),
            (num_mesh_x, num_mesh_y, num_mesh_z),
            "",
        )

        # face element of block can be generated by Block.face method
        bmd.add_boundary("wall", "frontAndBack", [b0.face("s"), b0.face("n")])
        bmd.add_boundary("wall", "topAndBottom", [b0.face("t"), b0.face("b")])
        bmd.add_boundary("wall", "hot", [b0.face("e")])
        bmd.add_boundary("wall", "cold", [b0.face("w")])

        return bmd.format(sort_vortices=False)
